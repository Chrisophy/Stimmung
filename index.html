<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stimmungs-Tagebuch mit Wetter & Schmerz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Setzt die Schriftart Inter */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
        }
        .mood-icon {
            font-size: 2.5rem;
            line-height: 1;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .mood-icon:hover {
            transform: scale(1.1);
        }
        .selected-mood {
            transform: scale(1.2) !important;
            box-shadow: 0 0 0 4px #4f46e5;
            border-radius: 9999px;
            padding: 4px;
        }
        .period-button {
            transition: background-color 0.2s, transform 0.1s;
        }
        .period-button:active {
            transform: scale(0.98);
        }
        .selected-period {
            background-color: #4f46e5 !important;
            color: white !important;
            font-weight: 600;
        }
        /* Styles fÃ¼r Schmerz-Buttons */
        .pain-button.selected-pain {
            transform: scale(1.1) !important;
            box-shadow: 0 0 0 3px #9333ea; /* Lila-Fokus */
            font-weight: 700;
            background-color: #9333ea !important; /* Lila-Hintergrund */
            color: white !important;
            border-color: #9333ea !important;
        }
    </style>
</head>
<body>

<div id="app" class="min-h-screen p-4 sm:p-6 max-w-lg mx-auto bg-white shadow-xl">
    <header class="text-center mb-6 pt-4">
        <h1 class="text-3xl font-extrabold text-indigo-700">Dein persÃ¶nliches Stimmungs-Tagebuch</h1>
        <p class="text-gray-500 mt-1">Wie geht es Dir?</p>
        <p id="weather-status" class="text-center text-sm text-gray-400 mt-2">Lade Standort...</p> 
    </header>

    <section class="p-6 bg-gray-50 rounded-xl shadow-inner mb-8">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Neuer Eintrag</h2>
        
        <div class="mb-6">
            <label for="entry-date" class="font-medium block mb-2">0. WÃ¤hle das Datum:</label>
            <input type="date" id="entry-date" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500" required>
        </div>
        <div class="mb-6">
            <p class="font-medium mb-2">1. WÃ¤hle die Tageszeit:</p>
            <div id="time-periods" class="grid grid-cols-2 sm:grid-cols-4 gap-3">
                <button class="period-button bg-white text-indigo-600 border border-indigo-300 rounded-lg p-3 text-center shadow-sm" data-period="Nacht">
                    ğŸŒ™ Nacht
                </button>
                <button class="period-button bg-white text-indigo-600 border border-indigo-300 rounded-lg p-3 text-center shadow-sm" data-period="Morgen">
                    ğŸŒ… Morgen
                </button>
                <button class="period-button bg-white text-indigo-600 border border-indigo-300 rounded-lg p-3 text-center shadow-sm" data-period="Mittag">
                    â˜€ï¸ Mittag
                </button>
                <button class="period-button bg-white text-indigo-600 border border-indigo-300 rounded-lg p-3 text-center shadow-sm" data-period="Abend">
                    ğŸŒ‡ Abend
                </button>
                </div>
        </div>

        <div class="mb-6">
            <p class="font-medium mb-2">2. WÃ¤hle deine Stimmung:</p>
            <div id="mood-selection" class="flex justify-around items-center space-x-2">
                <div class="mood-icon cursor-pointer" data-mood="sehr_gut" title="Sehr gut">ğŸ˜€</div>
                <div class="mood-icon cursor-pointer" data-mood="gut" title="Gut">ğŸ™‚</div>
                <div class="mood-icon cursor-pointer" data-mood="neutral" title="Neutral">ğŸ˜</div>
                <div class="mood-icon cursor-pointer" data-mood="schlecht" title="Schlecht">ğŸ™</div>
                <div class="mood-icon cursor-pointer" data-mood="sehr_schlecht" title="Sehr schlecht">ğŸ˜</div>
            </div>
        </div>
        
        <div class="mb-6">
            <p class="font-medium mb-2">3. SchmerzintensitÃ¤t (0-10):</p>
            <div id="pain-selection" class="flex flex-wrap justify-center sm:justify-between gap-1">
                <script>
                    // NEU: Startet bei 0
                    for(let i = 0; i <= 10; i++) { 
                        document.write(`
                            <button class="pain-button text-sm w-8 h-8 rounded-full border border-gray-300 transition duration-100 hover:bg-red-100" data-pain="${i}" title="${i === 0 ? 'Keine Schmerzen' : i === 10 ? 'StÃ¤rkste Schmerzen' : 'Schmerzstufe ' + i}">
                                ${i}
                            </button>
                        `);
                    }
                </script>
            </div>
        </div>
        <div class="mb-6">
            <label for="note" class="font-medium block mb-2">4. Notizen (optional):</label>
            <textarea id="note" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500" rows="2" placeholder="Was war heute wichtig oder wie fÃ¼hlst du dich genauer?"></textarea>
        </div>

        <button id="save-entry" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md disabled:opacity-50" disabled>
            Bitte Datum, Zeitraum, Stimmung und Schmerz wÃ¤hlen
        </button>

        <p id="status-message" class="mt-3 text-center text-sm font-medium h-4"></p>
    </section>
    
    <section class="mt-8 mb-8 p-6 bg-gray-50 rounded-xl shadow">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">ğŸ“ˆ Stimmungs-, Schmerz- & Wetterverlauf</h2>
        
        <div id="chart-container" class="relative h-64 w-full overflow-x-auto"> 
            <canvas id="moodChart" style="min-width: 300px;"></canvas>
            <p id="chart-status" class="absolute inset-0 flex items-center justify-center text-gray-500 hidden">
                Nicht genÃ¼gend Daten fÃ¼r ein Diagramm (min. 2 Tage).
            </p>
        </div>
        
        <div class="mt-4 text-sm text-center flex justify-center flex-wrap gap-x-4 gap-y-2">
            <p class="inline-block px-2 py-1 rounded-md bg-indigo-100 text-indigo-800 font-medium">Stimmung (Links: 1-5)</p>
            <p class="inline-block px-2 py-1 rounded-md bg-purple-100 text-purple-800 font-medium">Schmerz (Rechts: 0-10)</p>
            <p class="inline-block px-2 py-1 rounded-md bg-red-100 text-red-800 font-medium">Temperatur (Rechts: -5Â°C bis 25Â°C)</p>
        </div>
    </section>
    <section>
        <h2 class="text-xl font-semibold mb-4 text-gray-700">Deine Historie</h2>
        <p id="loading-history" class="text-center text-gray-500 mt-8">Lade EintrÃ¤ge...</p>
        <div id="history-container">
            </div>
        <p id="no-entries" class="text-center text-gray-500 py-10 hidden">Noch keine EintrÃ¤ge vorhanden. Starte jetzt!</p>
    </section>
    
    <section class="mt-8 mb-4">
        <h2 class="text-xl font-semibold mb-3 text-gray-700">Verwaltung</h2>
        <button id="reset-data" class="w-full bg-red-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-700 transition duration-150 shadow-md disabled:opacity-50">
            âŒ Alle EintrÃ¤ge lÃ¶schen (Neustart)
        </button>
        <p id="reset-status" class="mt-3 text-center text-sm font-medium h-4"></p>
    </section>

</div> 

<script>
    // --- LOKALE SPEICHERKONSTANTE ---
    const LOCAL_STORAGE_KEY = 'stimmungstagebuch_data';

    // Globale Variablen fÃ¼r das Formular
    let selectedPeriod = null;
    let selectedMood = null;
    let selectedPain = null; 

    // --- WETTER VARIABLEN (Open-Meteo, kostenfrei) ---
    const WEATHER_API_BASE_URL = "https://api.open-meteo.com/v1/forecast";
    let currentTemperatureData = null; 
    let userLatitude = null; 
    let userLongitude = null; 
    
    // ZeitrÃ¤ume und die zugehÃ¶rige Stunde fÃ¼r die Wetterzuordnung
    const PERIOD_TIME_MAP = {
        'Morgen': 9,  
        'Mittag': 13, 
        'Abend': 19,  
        'Nacht': 3    
    };

    // WMO Code Mapping 
    const WMO_CODE_MAP = {
        0: 'Klarer Himmel â˜€ï¸', 1: 'HauptsÃ¤chlich klar ğŸŒ¤ï¸', 2: 'Teilweise bewÃ¶lkt ğŸŒ¥ï¸', 3: 'Bedeckt â˜ï¸', 
        45: 'Nebel ğŸŒ«ï¸', 48: 'Reif-/GlÃ¤tte-Nebel ğŸŒ«ï¸', 51: 'Leichter Nieselregen ğŸŒ§ï¸', 53: 'MÃ¤ÃŸiger Nieselregen ğŸŒ§ï¸', 
        55: 'Starker Nieselregen ğŸŒ§ï¸', 56: 'Leichter gefrierender Nieselregen ğŸŒ¨ï¸', 57: 'Starker gefrierender Nieselregen ğŸŒ¨ï¸', 
        61: 'Leichter Regen ğŸŒ§ï¸', 63: 'MÃ¤ÃŸiger Regen ğŸŒ§ï¸', 65: 'Starker Regen ğŸŒ§ï¸', 
        66: 'Leichter gefrierender Regen â„ï¸', 67: 'Starker gefrierender Regen â„ï¸', 71: 'Leichter Schneefall ğŸŒ¨ï¸', 
        73: 'MÃ¤ÃŸiger Schneefall ğŸŒ¨ï¸', 75: 'Starker Schneefall ğŸŒ¨ï¸', 77: 'Schneegriesel â„ï¸', 
        80: 'Leichte Regenschauer ğŸŒ¦ï¸', 81: 'MÃ¤ÃŸige Regenschauer ğŸŒ¦ï¸', 82: 'Starke Regenschauer â›ˆï¸', 
        85: 'Leichte Schneeschauer ğŸŒ¨ï¸', 86: 'Starke Schneeschauer ğŸŒ¨ï¸', 95: 'Gewitter (leicht/mÃ¤ÃŸig) ğŸŒ©ï¸', 
        96: 'Gewitter mit leichtem Hagel â›ˆï¸', 99: 'Gewitter mit starkem Hagel â›ˆï¸'
    };
    // ----------------------------------------------------

    // Status-Elemente
    const entryDateEl = document.getElementById('entry-date'); 
    const timePeriodsEl = document.getElementById('time-periods');
    const moodSelectionEl = document.getElementById('mood-selection');
    const painSelectionEl = document.getElementById('pain-selection'); 
    const noteEl = document.getElementById('note');
    const saveButton = document.getElementById('save-entry');
    const statusMessageEl = document.getElementById('status-message');
    const historyContainerEl = document.getElementById('history-container');
    const loadingHistoryEl = document.getElementById('loading-history');
    const noEntriesEl = document.getElementById('no-entries');
    const resetButton = document.getElementById('reset-data'); 
    const resetStatusEl = document.getElementById('reset-status'); 
    const weatherStatusEl = document.getElementById('weather-status'); 
    
    entryDateEl.value = new Date().toISOString().split('T')[0]; 

    // Mappings
    const MOOD_EMOJIS = {
        'sehr_gut': 'ğŸ˜€', 'gut': 'ğŸ™‚', 'neutral': 'ğŸ˜', 'schlecht': 'ğŸ™', 'sehr_schlecht': 'ğŸ˜'
    };
    window.MOOD_NAMES = {
        'sehr_gut': 'Sehr gut', 'gut': 'Gut', 'neutral': 'Neutral', 'schlecht': 'Schlecht', 'sehr_schlecht': 'Sehr schlecht'
    };
    window.MOOD_VALUES = {
        'sehr_schlecht': 1, 'schlecht': 2, 'neutral': 3, 'gut': 4, 'sehr_gut': 5
    };


    /**
     * NEU: LÃ¤dt alle EintrÃ¤ge aus dem localStorage.
     * @returns {Array<object>} Die Liste der EintrÃ¤ge.
     */
    function loadEntriesFromLocalStorage() {
        try {
            const data = localStorage.getItem(LOCAL_STORAGE_KEY);
            return data ? JSON.parse(data) : [];
        } catch (e) {
            console.error("Fehler beim Laden aus localStorage:", e);
            return [];
        }
    }

    /**
     * NEU: Speichert die gesamte Liste von EintrÃ¤gen im localStorage.
     * @param {Array<object>} entries Die Liste der EintrÃ¤ge.
     */
    function saveEntriesToLocalStorage(entries) {
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(entries));
        } catch (e) {
            console.error("Fehler beim Speichern in localStorage:", e);
        }
    }


    /**
     * Der Firebase-Setup-Schritt wird durch das Laden der Historie ersetzt.
     */
    function setupApp() {
        // Starte das Laden der Historie sofort, da keine Firebase-Auth nÃ¶tig ist
        loadHistoryAndStartListening();
        // Starte Wetterabruf
        fetchWeather(); 
    }
    
    /**
     * Ruft den Standort des Benutzers ab und fragt die Wetterdaten ab.
     */
    async function fetchWeather() {
        if (currentTemperatureData && userLatitude && userLongitude) {
             weatherStatusEl.textContent = 'âœ… Wetterdaten bereit.';
             return;
        }

        weatherStatusEl.textContent = 'Lade Standort... (Bitte erlauben Sie den Zugriff)';

        if (!navigator.geolocation) {
            weatherStatusEl.textContent = 'Geolocation wird nicht unterstÃ¼tzt. Wetterdaten nicht verfÃ¼gbar.';
            return;
        }

        try {
            const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, { 
                    timeout: 10000,
                    enableHighAccuracy: false
                });
            });

            userLatitude = position.coords.latitude; 
            userLongitude = position.coords.longitude; 
            
            weatherStatusEl.textContent = 'Wetterdaten abrufen...';
            await fetchWeatherData(userLatitude, userLongitude);

        } catch (error) {
            console.error("Fehler beim Abrufen des Standorts:", error);
            if (error.code === error.PERMISSION_DENIED) {
                 weatherStatusEl.textContent = 'âŒ Standortzugriff verweigert. Wetterdaten nicht verfÃ¼gbar.';
            } else {
                 weatherStatusEl.textContent = 'âŒ Fehler beim Laden des Standorts. Eintrag ohne Wetter.';
            }
        }
    }

    /**
     * Ruft die Wetterdaten (stÃ¼ndliche Vorhersage) von Open-Meteo ab.
     */
    async function fetchWeatherData(lat, lon) {
        // Lade 14 Tage fÃ¼r Sicherheit
        const url = `${WEATHER_API_BASE_URL}?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,weathercode&timezone=auto&forecast_days=14`; 
        
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`API Fehler: ${response.status}`);
            
            const data = await response.json();
            
            const hourlyData = data.hourly.time.map((timestamp, index) => ({
                // API-Timestamp in Millisekunden umwandeln
                timestamp: new Date(timestamp).getTime(), 
                temp: data.hourly.temperature_2m[index],
                wmoCode: data.hourly.weathercode[index] 
            }));
            
            currentTemperatureData = hourlyData; // Wetterdaten speichern
            weatherStatusEl.textContent = 'âœ… Wetterdaten bereit.';

        } catch (error) {
            console.error("Fehler beim Abrufen der Wetterdaten:", error);
            weatherStatusEl.textContent = 'âŒ Fehler beim Laden der Wetterdaten. Eintrag ohne Temperatur/Wetterzustand.';
        }
    }

    /**
     * Ermittelt die Temperatur und den Wetterzustand fÃ¼r den ausgewÃ¤hlten Zeitraum.
     */
    function getWeatherDataForPeriod(period, selectedDateStr) { 
        
        if (!selectedDateStr) return { temperature: null, weatherCondition: null }; 

        if (!currentTemperatureData || currentTemperatureData.length === 0) {
             return { temperature: null, weatherCondition: null }; 
        }

        const targetHour = PERIOD_TIME_MAP[period];
        if (!targetHour) return { temperature: null, weatherCondition: null };

        // Erstelle das Zieldatum-Objekt basierend auf dem Formular-Datum und der Zielstunde (lokale Zeit)
        const [year, month, day] = selectedDateStr.split('-').map(Number);
        
        // TargetTime in der lokalen Zeitzone des Benutzers erstellen (wichtig fÃ¼r den Abgleich)
        let targetTime = new Date(year, month - 1, day, targetHour, 0, 0); 

        // Die Open-Meteo API liefert stÃ¼ndliche Timestamps. Wir finden den nÃ¤chstgelegenen.
        const targetTimestampMs = targetTime.getTime(); 
        
        let closestEntry = null;
        let minDiff = Infinity;
        
        currentTemperatureData.forEach(entry => {
            const diff = Math.abs(entry.timestamp - targetTimestampMs); 
            
            // Limit: Nur DatensÃ¤tze innerhalb von 12 Stunden der Zielzeit akzeptieren (Sicherheit)
            if (diff < minDiff && diff < (12 * 60 * 60 * 1000)) { 
                minDiff = diff;
                closestEntry = entry;
            }
        });

        if (closestEntry) {
            const temp = parseFloat(closestEntry.temp.toFixed(1));
            const condition = WMO_CODE_MAP[closestEntry.wmoCode] || 'Unbekannt'; 
            return { temperature: temp, weatherCondition: condition };
        } else {
            console.warn(`Keine Wetterdaten fÃ¼r ${selectedDateStr} - ${period} in den geladenen Daten gefunden.`);
            return { temperature: null, weatherCondition: null };
        }
    }

    /**
     * Aktiviert/Deaktiviert den Speichern-Button.
     */
    function checkFormValidity() {
        const selectedDate = entryDateEl.value; 
        // selectedPain muss nicht > 0 sein, sondern nur gesetzt sein (d.h. != null)
        saveButton.disabled = !(selectedDate && selectedPeriod && selectedMood && selectedPain !== null); 
        saveButton.textContent = saveButton.disabled ? 'Bitte Datum, Zeitraum, Stimmung und Schmerz wÃ¤hlen' : 'Eintrag speichern';
    }


    /**
     * Setzt die Event Listener fÃ¼r das Formular.
     */
    function setupFormListeners() {
        entryDateEl.addEventListener('change', checkFormValidity);

        timePeriodsEl.addEventListener('click', (e) => {
            const btn = e.target.closest('.period-button');
            if (btn) {
                document.querySelectorAll('.period-button').forEach(b => b.classList.remove('selected-period'));
                selectedPeriod = btn.dataset.period;
                btn.classList.add('selected-period');
                checkFormValidity();
            }
        });

        moodSelectionEl.addEventListener('click', (e) => {
            const icon = e.target.closest('.mood-icon');
            if (icon) {
                document.querySelectorAll('.mood-icon').forEach(i => i.classList.remove('selected-mood'));
                selectedMood = icon.dataset.mood;
                icon.classList.add('selected-mood');
                checkFormValidity();
            }
        });

        painSelectionEl.addEventListener('click', (e) => {
            const btn = e.target.closest('.pain-button');
            if (btn) {
                document.querySelectorAll('.pain-button').forEach(b => b.classList.remove('selected-pain'));
                // WICHTIG: parseInt(..., 10) stellt sicher, dass '0' korrekt als Zahl 0 gelesen wird
                selectedPain = parseInt(btn.dataset.pain, 10); 
                btn.classList.add('selected-pain');
                checkFormValidity();
            }
        });
        
        saveButton.addEventListener('click', saveEntry);
        resetButton.addEventListener('click', resetData); 
        checkFormValidity();
    }

    /**
     * NEU: Speichert den aktuellen Stimmungseintrag in localStorage.
     */
    function saveEntry() {
        const entryDate = entryDateEl.value; 
        if (!entryDate || !selectedPeriod || !selectedMood || selectedPain === null) {
            statusMessageEl.textContent = "Bitte alle notwendigen Felder (Datum, Zeitraum, Stimmung, Schmerz) ausfÃ¼llen.";
            statusMessageEl.className = 'mt-3 text-center text-sm font-medium text-red-600 h-4';
            return;
        }

        saveButton.disabled = true;
        statusMessageEl.textContent = 'Speichere...';
        statusMessageEl.className = 'mt-3 text-center text-sm font-medium text-blue-600 h-4';

        // Eindeutige ID aus Datum und Zeitraum
        const docId = `${entryDate}_${selectedPeriod}`; 
        
        const weather = getWeatherDataForPeriod(selectedPeriod, entryDate); 

        // EintrÃ¤ge laden
        const allEntries = loadEntriesFromLocalStorage();
        
        const newEntry = {
            id: docId, // Verwenden Sie die DocId als lokale ID
            date: entryDate, 
            timePeriod: selectedPeriod,
            mood: selectedMood,
            pain: selectedPain, 
            note: noteEl.value.trim(),
            temperature: weather.temperature, 
            weatherCondition: weather.weatherCondition, 
            timestamp: new Date().getTime() // Lokaler Zeitstempel
        };

        // Bestehenden Eintrag finden und Ã¼berschreiben oder neuen hinzufÃ¼gen
        const existingIndex = allEntries.findIndex(e => e.id === docId);
        if (existingIndex > -1) {
            allEntries[existingIndex] = newEntry; // Ãœberschreiben
        } else {
            allEntries.push(newEntry); // HinzufÃ¼gen
        }

        try {
            saveEntriesToLocalStorage(allEntries);

            statusMessageEl.textContent = 'Eintrag erfolgreich gespeichert!';
            statusMessageEl.className = 'mt-3 text-center text-sm font-medium text-green-600 h-4';

            // Historie neu rendern
            renderSortedHistory(allEntries);

            // Formular zurÃ¼cksetzen
            setTimeout(() => {
                entryDateEl.value = new Date().toISOString().split('T')[0]; 
                noteEl.value = '';
                selectedPeriod = null;
                selectedMood = null;
                selectedPain = null; 
                document.querySelectorAll('.period-button, .mood-icon, .pain-button').forEach(el => el.classList.remove('selected-period', 'selected-mood', 'selected-pain')); 
                checkFormValidity();
                statusMessageEl.textContent = '';
            }, 1500);

        } catch (error) {
            console.error("Fehler beim Speichern des Eintrags:", error);
            statusMessageEl.textContent = 'Fehler beim Speichern. (Speicher voll?)';
            statusMessageEl.className = 'mt-3 text-center text-sm font-medium text-red-600 h-4';
        } finally {
            saveButton.disabled = false;
        }
    }


    /**
     * NEU: LÃ¤dt die Historie aus localStorage und startet das Rendering.
     */
    function loadHistoryAndStartListening() {
        const allEntries = loadEntriesFromLocalStorage();
        renderSortedHistory(allEntries);
    }
    
    /**
     * Sortiert die EintrÃ¤ge und ruft das Rendering auf.
     */
    function renderSortedHistory(allEntries) {
         // Sortierung: Neuestes Datum zuerst, dann nach Tageszeit (Nacht -> Abend)
        const sortedEntries = allEntries.sort((a, b) => {
            if (a.date < b.date) return 1;
            if (a.date > b.date) return -1;
            
            const order = ['Nacht', 'Morgen', 'Mittag', 'Abend']; 
            return order.indexOf(a.timePeriod) - order.indexOf(b.timePeriod);
        });

        renderHistory(sortedEntries);
    }


    /**
     * Rendert die Historie in HTML und Ã¼bergibt die Daten an das Chart.
     * (UnverÃ¤ndert, verwendet jetzt lokal geladene Daten)
     * @param {Array<object>} entries Alle sortierten StimmungseintrÃ¤ge.
     */
    function renderHistory(entries) {
        loadingHistoryEl.classList.add('hidden');
        historyContainerEl.innerHTML = '';

        if (entries.length === 0) {
            noEntriesEl.classList.remove('hidden');
            if (typeof renderMoodChart !== 'undefined') {
                renderMoodChart([]); 
            }
            return;
        }

        noEntriesEl.classList.add('hidden');

        // EintrÃ¤ge nach Datum gruppieren
        const groupedByDate = entries.reduce((acc, entry) => {
            const dateKey = entry.date;
            if (!acc[dateKey]) {
                acc[dateKey] = [];
            }
            // HinzufÃ¼gen des Timestamps fÃ¼r eine eventuelle sekundÃ¤re Sortierung
            entry.timestamp = entry.timestamp || new Date(entry.date).getTime(); 
            acc[dateKey].push(entry);
            return acc;
        }, {});

        // Daten des Diagramms rendern
        if (typeof renderMoodChart !== 'undefined') {
            renderMoodChart(entries); 
        }

        // HTML-Elemente fÃ¼r die Historie erstellen
        const sortedDates = Object.keys(groupedByDate).sort().reverse();

        sortedDates.forEach(date => {
            const dateGroup = document.createElement('div');
            dateGroup.className = 'mb-6 border border-gray-200 rounded-lg shadow-md overflow-hidden';

            const dateTitle = document.createElement('h3');
            dateTitle.className = 'bg-indigo-100 text-indigo-800 font-bold p-3 text-lg border-b border-indigo-200';
            dateTitle.textContent = formatDate(date);
            dateGroup.appendChild(dateTitle);

            const entriesList = document.createElement('div');
            // Sicherstellen, dass das richtige Array (groupedByDate[date]) verwendet wird
            groupedByDate[date].forEach(entry => { 
                entriesList.innerHTML += createEntryHtml(entry);
            });
            dateGroup.appendChild(entriesList);

            historyContainerEl.appendChild(dateGroup);
        });
    }


    function createEntryHtml(entry) {
        const moodEmoji = MOOD_EMOJIS[entry.mood] || 'â“';
        const moodName = window.MOOD_NAMES[entry.mood] || 'Unbekannt';
        
        const painDisplay = entry.pain !== undefined && entry.pain !== null 
                             ? `<span class="text-purple-600 font-bold ml-2">Schmerz: ${entry.pain}/10</span>`
                             : '';

        let weatherLine = '';
        if (entry.temperature !== undefined && entry.temperature !== null) {
            weatherLine += `${entry.temperature}Â°C`;
        }
        if (entry.weatherCondition) {
             if (weatherLine) weatherLine += ' Â· ';
             weatherLine += entry.weatherCondition;
        }

        return `
            <div class="flex justify-between items-center py-3 px-4 bg-white border-b border-gray-100 last:border-b-0">
                <div class="flex items-center space-x-3">
                    <span class="text-xl font-bold text-indigo-500">${entry.timePeriod}</span>
                    <span class="text-3xl">${moodEmoji}</span>
                    <div class="text-sm">
                        <p class="font-semibold text-gray-700">${moodName}${painDisplay}</p>
                        ${entry.note || weatherLine ? 
                            `<p class="text-gray-500 italic text-xs">${entry.note ? entry.note + (weatherLine ? ' | ' : '') : ''}${weatherLine}</p>` 
                        : ''}
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * NEU: LÃ¶scht alle gespeicherten Daten aus dem localStorage.
     */
    function resetData() {
        if (!confirm("WARNUNG! Sind Sie sicher, dass Sie ALLE EintrÃ¤ge lÃ¶schen mÃ¶chten? Dieser Vorgang kann nicht rÃ¼ckgÃ¤ngig gemacht werden!")) {
            return;
        }

        resetButton.disabled = true;
        resetStatusEl.textContent = 'LÃ¶sche alle Daten...';
        resetStatusEl.className = 'mt-3 text-center text-sm font-medium text-yellow-600 h-4';

        try {
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            
            resetStatusEl.textContent = `Erfolgreich alle EintrÃ¤ge gelÃ¶scht!`;
            resetStatusEl.className = 'mt-3 text-center text-sm font-medium text-green-600 h-4';
            
            // UI neu rendern
            renderHistory([]); 

        } catch (error) {
            console.error("Fehler beim LÃ¶schen der EintrÃ¤ge:", error);
            resetStatusEl.textContent = 'Fehler beim LÃ¶schen.';
            resetStatusEl.className = 'mt-3 text-center text-sm font-medium text-red-600 h-4';
        } finally {
            resetButton.disabled = false;
            setTimeout(() => { resetStatusEl.textContent = ''; }, 3000);
        }
    }


    function formatDate(dateString) {
        try {
            const [year, month, day] = dateString.split('-').map(Number);
            const date = new Date(Date.UTC(year, month - 1, day)); 
            return date.toLocaleDateString('de-DE', { 
                weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
            });
        } catch (e) {
            return dateString;
        }
    }

    // Datumsformatierung fÃ¼r Chart (MUSS GLOBAL SEIN)
    window.formatDateShort = function(dateString) {
        try {
            const [year, month, day] = dateString.split('-').map(Number);
            const date = new Date(Date.UTC(year, month - 1, day)); 
            return date.toLocaleDateString('de-DE', { 
                weekday: 'short', day: 'numeric', month: 'short' 
            }).replace(/\./g, '').trim(); 
        } catch (e) {
            return dateString;
        }
    }

    // --- START DER ANWENDUNG ---
    setupFormListeners(); 
    setupApp(); // Startet die App, lÃ¤dt Historie und Wetter
</script>


<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.js"></script>
<script>
    // Dieses Skript ist unverÃ¤ndert und greift nun auf die globalen Variablen und 
    // die Funktion renderHistory zu, die ihre Daten aus localStorage bezieht.

    let moodChartInstance = null;
    const chartStatusEl = document.getElementById('chart-status');
    const moodChartEl = document.getElementById('moodChart'); // Das Canvas-Element
    const chartContainerEl = document.getElementById('chart-container'); // Der scrollbare Container

    // --- TEMPERATUR-NORMALISIERUNGSKONSTANTEN ---
    // Definiert den Temperaturbereich, der auf die Skala 0-10 abgebildet wird.
    const TEMP_MIN = -5;  // -5.0Â°C entspricht Wert 0
    const TEMP_MAX = 25;  // 25.0Â°C entspricht Wert 10
    const TEMP_RANGE = TEMP_MAX - TEMP_MIN; // 30Â°C (25 - (-5))

    /**
     * Skaliert eine Temperatur von [TEMP_MIN, TEMP_MAX] linear auf [0, 10].
     * @param {number} temp Die tatsÃ¤chliche Temperatur in Â°C.
     * @returns {number} Der normalisierte Wert zwischen 0, 10.
     */
    function normalizeTemperature(temp) {
        if (temp === null || temp === undefined) return null;
        if (TEMP_RANGE === 0) return 5; 

        // Begrenzt den Wert auf den definierten Bereich, damit er nicht auÃŸerhalb von 0-10 skaliert
        let clampedTemp = Math.max(TEMP_MIN, Math.min(TEMP_MAX, temp)); 
        
        // Normalisierungsformel: (Wert - Min) / Range * 10
        return ((clampedTemp - TEMP_MIN) / TEMP_RANGE) * 10;
    }

    /**
     * Re-transformiert einen normalisierten Wert (0-10) zurÃ¼ck in die tatsÃ¤chliche Temperatur.
     * @param {number} normalizedValue Der normalisierte Wert.
     * @returns {number} Die tatsÃ¤chliche Temperatur in Â°C.
     */
    function denormalizeTemperature(normalizedValue) {
        if (normalizedValue === null || normalizedValue === undefined) return null;
        // Denormalisierungsformel: (Normalisierter Wert / 10 * Range) + Min
        return (normalizedValue / 10 * TEMP_RANGE) + TEMP_MIN;
    }
    // ----------------------------------------------------


    /**
     * Berechnet den durchschnittlichen Stimmungswert, Temperatur und SCHMERZ pro Tag und rendert das Diagramm.
     * @param {Array<object>} entries Alle StimmungseintrÃ¤ge.
     */
    function renderMoodChart(entries) {
        if (typeof Chart === 'undefined') { return; }

        if (moodChartInstance) { moodChartInstance.destroy(); }
        
        // 1. Daten pro Tag gruppieren und Durchschnitt berechnen
        const dailyData = entries.reduce((acc, entry) => {
            const dateKey = entry.date;
            const moodValue = window.MOOD_VALUES[entry.mood] || 3; 
            const tempValue = entry.temperature || null; 
            const painValue = entry.pain; // Wert kann 0 sein
            
            if (!acc[dateKey]) {
                acc[dateKey] = { 
                    moodSum: 0, moodCount: 0, 
                    tempSum: 0, tempCount: 0, 
                    painSum: 0, painCount: 0, 
                };
            }
            
            acc[dateKey].moodSum += moodValue;
            acc[dateKey].moodCount++;
            
            if (tempValue !== null) {
                // Hier den ORIGINALEN Wert zur Summe hinzufÃ¼gen
                acc[dateKey].tempSum += tempValue;
                acc[dateKey].tempCount++;
            }
            
            // Schmerz ist nur dann gÃ¼ltig, wenn es nicht null oder undefined ist (auch 0 ist gÃ¼ltig)
            if (painValue !== undefined && painValue !== null) {
                acc[dateKey].painSum += painValue;
                acc[dateKey].painCount++;
            }
            
            return acc;
        }, {});

        // 2. Daten fÃ¼r das Diagramm formatieren
        const sortedDates = Object.keys(dailyData).sort();
        const chartData = sortedDates.map(date => {
            const data = dailyData[date];

            // Berechnung des Durchschnitts (Originalwert)
            const averageTempOriginal = data.tempCount > 0 ? data.tempSum / data.tempCount : null;
            
            return {
                date: date,
                averageMood: data.moodCount > 0 ? data.moodSum / data.moodCount : null,
                // Normalisierter Temperaturwert fÃ¼r die Grafik
                averageTempNormalized: normalizeTemperature(averageTempOriginal),
                averagePain: data.painCount > 0 ? data.painSum / data.painCount : null, 
                averageTempOriginal: averageTempOriginal // Originalwert fÃ¼r Tooltip behalten
            };
        });

        // Zeige Warnung, wenn zu wenige Daten vorhanden sind
        if (chartData.length < 2) {
            chartStatusEl.classList.remove('hidden');
            moodChartEl.style.width = '100%'; 
            return;
        }
        chartStatusEl.classList.add('hidden');

        // **********************************************
        // LOGIK FÃœR DYNAMISCHE BREITENANPASSUNG 
        // **********************************************
        const numDataPoints = chartData.length;
        const PIXELS_PER_DATA_POINT = 60; 
        const calculatedWidth = numDataPoints * PIXELS_PER_DATA_POINT;
        let finalChartWidth = Math.max(400, calculatedWidth); 
        
        moodChartEl.style.width = `${finalChartWidth}px`;
        moodChartEl.height = 256; 
        // **********************************************

        const ctx = moodChartEl.getContext('2d');
        const labels = chartData.map(d => window.formatDateShort(d.date)); 
        const moodData = chartData.map(d => d.averageMood);
        // Verwende normalisierte Temperaturdaten
        const tempDataNormalized = chartData.map(d => d.averageTempNormalized);
        const painData = chartData.map(d => d.averagePain); 
        
        // 3. Diagramm rendern mit DREI Datasets und DREI Achsen
        moodChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Ã˜ Stimmung (1=Schlecht, 5=Gut)',
                        data: moodData,
                        borderColor: '#4f46e5', // Indigo-600
                        backgroundColor: 'rgba(79, 70, 229, 0.2)',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 5,
                        pointBackgroundColor: '#4f46e5',
                        yAxisID: 'mood', 
                        order: 1,
                    },
                    {
                        label: 'Ã˜ Schmerz (0-10)', 
                        data: painData,
                        borderColor: '#9333ea', // Lila-600
                        backgroundColor: 'rgba(147, 51, 234, 0.3)',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 5,
                        pointBackgroundColor: '#9333ea',
                        yAxisID: 'pain', // Achse fÃ¼r Schmerz (und Temperaturlinie)
                        type: 'line', 
                        order: 3, 
                    },
                    {
                        label: 'Ã˜ Temperatur (Skaliert)', // Angepasstes Label
                        data: tempDataNormalized, // Normalisierte Daten
                        borderColor: '#ef4444', // Red-500
                        backgroundColor: 'rgba(239, 68, 68, 0.4)',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 5,
                        pointBackgroundColor: '#ef4444',
                        yAxisID: 'pain', // Verwendet dieselbe Achse wie Schmerz
                        type: 'line', 
                        order: 2,
                    }
                ]
            },
            options: {
                responsive: false, 
                maintainAspectRatio: false, 
                scales: {
                    mood: {
                        type: 'linear',
                        position: 'left',
                        min: 1,
                        max: 5,
                        stepSize: 1,
                        title: { display: true, text: 'Stimmungswert' },
                        ticks: {
                            color: '#4f46e5',
                            callback: function(value) {
                                const moodName = Object.keys(window.MOOD_VALUES).find(key => window.MOOD_VALUES[key] === value);
                                return moodName ? window.MOOD_NAMES[moodName] : value;
                            }
                        }
                    },
                    pain: { // Achse A: Schmerzskala (Lila Ticks)
                        type: 'linear',
                        position: 'right', 
                        id: 'pain',
                        min: 0, // WICHTIG: Min ist jetzt 0
                        max: 10, 
                        stepSize: 1, 
                        grid: {
                            drawOnChartArea: false 
                        },
                        title: {
                            display: false, // Achsentitel entfernt
                        },
                        ticks: {
                            // Ticks in der Farbe der Schmerzlinie (Lila)
                            color: '#9333ea', 
                            callback: function(value) {
                                // Zeigt NUR die reine Schmerzskala (0-10)
                                return value.toFixed(0); 
                            },
                            // Setze Padding, damit die Beschriftungen der Temp-Referenz rechts daneben Platz haben
                            padding: 30, 
                        }
                    },
                    temp_ref: { // Achse B: Temperatur-Referenz (Rote Ticks, Ã¼berlappend)
                        type: 'linear',
                        position: 'right', 
                        id: 'temp_ref',
                        min: 0, 
                        max: 10, 
                        stepSize: 1, 
                        // Achse direkt Ã¼ber der 'pain'-Achse positionieren
                        grid: {
                            drawOnChartArea: false,
                            borderColor: 'transparent', // Keine zusÃ¤tzliche Linie
                            drawTicks: false // Zeichnet keine eigenen Tick-Markierungen
                        },
                        title: { 
                            display: false // Achsentitel entfernt
                        },
                        
                        ticks: {
                            // Ticks in der Farbe der Temperaturlinie (Rot)
                            color: '#ef4444', 
                            callback: function(value) {
                                // Die tatsÃ¤chliche Temperatur (denormalisiert)
                                const tempValue = denormalizeTemperature(value);
                                // Wir zeigen die Temperatur-Referenz in Klammern an
                                return `(â‰ˆ${tempValue.toFixed(1)}Â°C)`; 
                            },
                            // Kein Padding, damit die Beschriftung direkt nach dem Padding der 'pain'-Achse beginnt
                            padding: 0, 
                        }
                    },
                    x: {
                        beginAtZero: false, 
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';

                                if (label) {
                                    label += ': ';
                                }
                                if (context.dataset.yAxisID === 'mood') {
                                    const value = context.parsed.y;
                                    const mood = Object.keys(window.MOOD_VALUES).find(key => window.MOOD_VALUES[key] === Math.round(value));
                                    label += `${value.toFixed(2)} (${mood ? window.MOOD_NAMES[mood] : 'Unbekannt'})`;
                                } else if (context.dataset.label.includes('Schmerz')) { 
                                    label += `${context.parsed.y.toFixed(1)}/10`;
                                } else if (context.dataset.label.includes('Temperatur')) { 
                                    const normalized = context.parsed.y;
                                    const actualTemp = denormalizeTemperature(normalized);
                                    
                                    label = `Ã˜ Temperatur: ${actualTemp.toFixed(1)}Â°C`; 
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });
        
        // BONUS: Nach dem Laden automatisch an den rechten Rand scrollen (aktuellstes Datum)
        chartContainerEl.scrollLeft = chartContainerEl.scrollWidth;
    }

</script>
</body>
</html>
